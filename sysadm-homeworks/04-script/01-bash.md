# Домашнее задание к занятию "4.1. Командная оболочка Bash: Практические навыки"

## Обязательные задания

1. Есть скрипт:

    ```bash
    a=1
    b=2
    c=a+b
    d=$a+$b
    e=$(($a+$b))
    ```

    * Какие значения переменным c,d,e будут присвоены?
    * Почему?

        ---

        ```bash
        vagrant@vagrant:~$ a=1
        vagrant@vagrant:~$ b=2
        vagrant@vagrant:~$ c=a+b
        vagrant@vagrant:~$ d=$a+$b
        vagrant@vagrant:~$ e=$(($a+$b))
        vagrant@vagrant:~$ echo "c=$c; d=$d; e=$e"
        c=a+b; d=1+2; e=3
        ```

        * Все переменные определяются неявно. Следовательно, если переменной присваивается значение состоящие из цифр, то тип переменной будет **целое число**. Если любые другие символы - будет тип **строка**.
        * Переменная `с` будет строкой `a+b`, так как нет указаний интерпретатору, что `a` и `b` переменные.
        * Переменная `d` также будет строкой (`1+2`), так как интерпретатор посчитает, что мы хотим вставить переменные `a` и `b` внутрь строки.
        * Переменная `e` выдаст результат арифметической операции сложения переменных `a` и `b`, так как мы явно это указали.

        ---

1. На нашем локальном сервере упал сервис и мы написали скрипт, который постоянно проверяет его доступность, записывая дату проверок до тех пор, пока сервис не станет доступным. В скрипте допущена ошибка, из-за которой выполнение не может завершиться, при этом место на Жёстком Диске постоянно уменьшается. Что необходимо сделать, чтобы его исправить:

    ```bash
    while ((1==1)
    do
    curl https://localhost:4757
    if (($? != 0))
    then
    date >> curl.log
    fi
    done
    ```

     ---

    * Мой вариант скрипта:

        ```bash
        #!/usr/bin/env bash
        while ((1==1))
        do
            curl https://localhost:4757

            if (($? != 0))
            then
                date >> curl.log
            else
                break
            fi
        done
        ```

    ---

1. Необходимо написать скрипт, который проверяет доступность трёх IP: 192.168.0.1, 173.194.222.113, 87.250.250.242 по 80 порту и записывает результат в файл log. Проверять доступность необходимо пять раз для каждого узла.

    ---

    ```bash
    #!/usr/bin/env bash
    hosts=(192.168.0.1 173.194.222.113 87.250.250.242)

    >log

    for host in ${!hosts[@]}
    do
        for iter in {1..5}
        do
            nc -zvw1 ${hosts[$host]} 80 2>> log
        done
    done
    ```

    ---

1. Необходимо дописать скрипт из предыдущего задания так, чтобы он выполнялся до тех пор, пока один из узлов не окажется недоступным. Если любой из узлов недоступен - IP этого узла пишется в файл error, скрипт прерывается

    ---

    ```bash
    #!/usr/bin/env bash
    HOSTS=(192.168.0.1 173.194.222.113 87.250.250.242)
    FILE_LOG=log
    FILE_ERROR=error

    >$FILE_LOG
    >$FILE_ERROR

    for host in ${!HOSTS[@]}
    do
        for iter in {1..5}
        do
            nc -zvw1 ${HOSTS[$host]} 80 2>> $FILE_LOG
            if [ $? != 0 ]
            then
                echo ${HOSTS[$host]} >> $FILE_ERROR
                break
            fi
        done
    done
    ```

    ---

## Дополнительное задание (со звездочкой*) - необязательно к выполнению

Мы хотим, чтобы у нас были красивые сообщения для коммитов в репозиторий. Для этого нужно написать локальный хук для git, который будет проверять, что сообщение в коммите содержит код текущего задания в квадратных скобках и количество символов в сообщении не превышает 30. Пример сообщения: \[04-script-01-bash\] сломал хук.

