# Домашнее задание к занятию "3.2. Работа в терминале, лекция 2"

1. Какого типа команда cd? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.

    - Команда `cd` в `Bash` является встроенной.

    ```shell
    vagrant@vagrant:~$ type cd
    cd is a shell builtin
    ```

    - Каждый запущенный процесс обладает своей виртуальной памятью и своим перечнем переменных окружения. Рабочий каталог один из этих параметров. Когда родительский процесс порождает дочерний, последний наследует все значения переменных окружения от родителя.

    - Если допустить, что команда `cd` будет отдельной программой, запущенной как процесс, то изменение рабочего каталога будет только у процесса `cd`, у родительского процесса рабочий каталог не изменится.

2. Какая альтернатива без pipe команде grep <some_string> <some_file> | wc -l? man grep поможет в ответе на этот вопрос. Ознакомьтесь с [документом](http://www.smallo.ruhr.de/award.html) о других подобных некорректных вариантах использования pipe.

    - Конструкцию можно заменить простым вызовом команды `grep` с параметром `--count`.

    ```shell
    vagrant@vagrant:~$ grep --count <some_string> <some_file>
    ```

3. Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?

    - Самым первым запущенным процессом, получающим PID 1, является система инициализации (загрузчик) - процесс, который будет управлять загрузкой остальных процессов, необходимых для функционирования операционной системы.

    - Для **Ubuntu 20.04** процесс с PID 1 - это `systemd`.

    ```shell
    vagrant@vagrant:~$ pstree -p
    systemd(1)─┬─VBoxService(841)─┬─{VBoxService}(843)
            │                  ├─{VBoxService}(844)
            │                  ├─{VBoxService}(845)
            │                  ├─{VBoxService}(846)
            │                  ├─{VBoxService}(847)
            │                  ├─{VBoxService}(848)
            │                  ├─{VBoxService}(849)
            │                  └─{VBoxService}(850)
            ├─accounts-daemon(657)─┬─{accounts-daemon}(662)
            │                      └─{accounts-daemon}(714)
    ...
    ```

4. Как будет выглядеть команда, которая перенаправит вывод **stderr** `ls` на другую сессию терминала?
 
    ```shell
    vagrant@vagrant:~$ ls -l /dev/pts4/ 2>/dev/tty1
    ```

5. Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.

    ```shell
    vagrant@vagrant:~$ tee <test.md >out.md
    ```

6. Получится ли вывести находясь в графическом режиме данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?

    - Да, можем:

    ```shell
    vagrant@vagrant:~$ ls -l >/dev/tty1
    ```

    - В этом примере создана сессия через `vagrant ssh` со своим выделенным PTY, вторая сессия создана непосредственно через **virtualbox** с выделением TTY. Внутри SSH-сессии выполняется команда получения данных о файлах рабочего каталога, результат которой выводится в сессии открытой в **virtualbox**.

7. Выполните команду bash 5>&1. К чему она приведет? Что будет, если вы выполните echo netology > /proc/$$/fd/5? Почему так происходит?

    ```shell
    vagrant@vagrant:~$ bash 5>&1
    vagrant@vagrant:~$ echo netology > /proc/$$/fd/5
    netology
    vagrant@vagrant:~$ ls -l /proc/$$/fd/
    total 0
    lrwx------ 1 vagrant vagrant 64 Feb  9 10:12 0 -> /dev/pts/0
    lrwx------ 1 vagrant vagrant 64 Feb  9 10:12 1 -> /dev/pts/0
    lrwx------ 1 vagrant vagrant 64 Feb  9 10:12 2 -> /dev/pts/0
    lrwx------ 1 vagrant vagrant 64 Feb  9 10:12 255 -> /dev/pts/0
    lrwx------ 1 vagrant vagrant 64 Feb  9 10:10 5 -> /dev/pts/0
    ```

    - Командой `bash 5>&1` мы запустим ещё один командный интерпретатор **bash** и свяжем его файловый дескриптор **5** со стандартным потоком вывода.
    - При выполнении команды `echo netology > /proc/$$/fd/5` мы перенаправляем результат **echo** в файл **/proc/$$/fd/5**, теперь соответствующий стандартному потоку вывода. То есть увидим сообщение `netology` в консоли.

8. Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout команды слева от `|` на stdin команды справа. Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.

    - Нормальная работа `pipe`:

    ```shell
    vagrant@vagrant:~$ ls | tee > out.tmp
    vagrant@vagrant:~$ ls fignya | tee > out.tmp
    ls: cannot access 'fignya': No such file or directory
    ```

    - Меняем местами потоки `stdout` и `stderr`:

    ```shell
    vagrant@vagrant:~$ ls 6>&1 1>&2 2>&6 | tee > out.tmp
    out.md  out.tmp  test.md  t.tmp
    vagrant@vagrant:~$ ls fignya 6>&1 1>&2 2>&6 | tee > out.tmp
    vagrant@vagrant:~$ 
    ```

9. Что выведет команда cat /proc/$$/environ? Как еще можно получить аналогичный по содержанию вывод?

    - Файл содержит переменные окружения для конкретного процесса. В нашем случае это процесс командной оболочки.
    - Сопоставимый вывод можно получить командами `ps e --no-headers -ww oargs -p $$`, `printenv -0` или `env`.

10. Используя man, опишите что доступно по адресам /proc/<PID>/cmdline, /proc/<PID>/exe.

    - `/proc/<PID>/cmdline` содержит команду с параметрами командной строки, с помощью которой запущен процесс `<PID>`;
    - `/proc/<PID>/exe` - это символическая ссылка на исполняемый файл процесса `<PID>`.

11. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью /proc/cpuinfo.

    ```shell
    vagrant@vagrant:~$ grep -Eo '\<sse[1-9]*[^ ]*' /proc/cpuinfo -m1
    sse
    sse2
    sse4_1
    sse4_2
    sse4a
    vagrant@vagrant:~$ 
    ```

    - Ответ: SSE4a

12. При открытии нового окна терминала и `vagrant ssh` создается новая сессия и выделяется pty. Это можно подтвердить командой `tty`, которая упоминалась в лекции 3.2. Однако:

    ```shell
    vagrant@netology1:~$ ssh localhost 'tty'
    not a tty
    ```

    - Когда используется такая конструкция, команда выполняется в неинтерактивной сессии, то есть не создаётся псевдо-терминал PTY;

    - В случае отсутствия команды 'tty', `ssh` установит интерактивную сессию и организует PTY для взаимодействия с пользователем;

    - Изменить такое поведение можно ключами `-T` (не выделять псевдо-терминал PTY для сессии) и `-t` (принудительно выделять псевдо-терминал PTY для сессии).

    ```shell
    vagrant@vagrant:~$ ssh localhost tty
    vagrant@localhost's password: 
    not a tty
    vagrant@vagrant:~$ ssh -t localhost tty
    vagrant@localhost's password: 
    /dev/pts/1
    Connection to localhost closed.
    vagrant@vagrant:~$
    ```

13. Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись `reptyr`. Например, так можно перенести в `screen` процесс, который вы запустили по ошибке в обычной SSH-сессии.

    - Установил **reptyr** с помощью команды `sudo apt-get install retpyr`;
    - В файле `/proc/sys/kernel/yama/ptrace_scope` сохранил '0';
    - Запустил `htop` и приостановил его работу нажатием клавиш **Ctrl+z**;
    - Перевёл процесс на работу в фоне командой `bg`;
    - Отвязал процесс от текущей сессии командой `disown htop` и запомнил PID процесса;
    - Запустил терминальный мультиплексор **tmux**;
    - Перенёс в новую сессию процесс **htop** командой `reptyr <PID>`;
    - Завершил все SSH-сессии;
    - Открыл новую SSH-сессию и выполнил команду `tmux attach`. В итоге получил работающий процесс `htop`.

14. `sudo echo string > /root/new_file` не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без `sudo` под вашим пользователем. Для решения данной проблемы можно использовать конструкцию `echo string | sudo tee /root/new_file`. Узнайте что делает команда `tee` и почему в отличие от `sudo echo` команда с `sudo tee` будет работать.

    - `sudo echo string > /root/new_file` не будет работать, так как перенаправление будет работать в контексте обычного пользователя. То есть `sudo echo string` отработает в контексте привилегированного пользователя, а перенаправление в файл `> /root/new_file` - уже от обычного пользователя.

    - В конструкции `echo string | sudo tee /root/new_file` иначе. `echo string` действует в контексте обычного пользователя и вывод перенаправляется в поток `stdin` процесса tee, запущенного в привилегированном контексте (`sudo tee /root/new_file`). `tee` принимает данные из `stdin` и может сохранить их в файл.
