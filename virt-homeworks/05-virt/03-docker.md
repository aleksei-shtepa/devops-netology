
# Домашнее задание к занятию "5.3. Введение. Экосистема. Архитектура. Жизненный цикл Docker контейнера"

## Задача 1

> Сценарий выполения задачи:
>
> - создайте свой репозиторий на https://hub.docker.com;
> - выберете любой образ, который содержит веб-сервер Nginx;
> - создайте свой fork образа;
> - реализуйте функциональность:
> запуск веб-сервера в фоне с индекс-страницей, содержащей HTML-код ниже:
>
> ```html
> <html>
> <head>
> Hey, Netology
> </head>
> <body>
> <h1>I’m DevOps Engineer!</h1>
> </body>
> </html>
> ```
>
> Опубликуйте созданный форк в своем репозитории и предоставьте ответ в виде ссылки на `https://hub.docker.com/username_repo`.

[Личный репозиторий на hub.docker.com](https://hub.docker.com/u/alekseishtepa)

[Домашнее задание](https://hub.docker.com/r/alekseishtepa/devops16)

## Задача 2

> Посмотрите на сценарий ниже и ответьте на вопрос:  
> "Подходит ли в этом сценарии использование Docker контейнеров или лучше подойдет виртуальная машина, физическая машина? Может быть возможны разные варианты?"
>
> Детально опишите и обоснуйте свой выбор.

---

Общим критерием выбора вариант будет платформа сценария. Docker-контейнеры могут быть реализованы только на базе ОС Linux, на других платформах контейнеры будут помещаться в виртуальную машину (получим гетерогенную среду).

Следовательно, для Linux предпочтительнее использовать виртуализацию уровня ядра ОС или контейнеризацию. Docker-контейнеры в значительной степени упрощают процесс администрирования упакованных в них приложений.

Сценарий:

> - Высоконагруженное монолитное java веб-приложение;

Java web-приложение - это скорее всего сервер приложений с набором сервлетов. Их вполне можно упаковать в Docker stateless-контейнер.

> - Nodejs веб-приложение;

Как правило, web-приложения свои изменяемые данные хранят в СУБД, а сами представляют собой неизменяемый набор файлов. Следовательно любое web-приложение можно упаковать в Docker stateless-контейнер, Node.js не исключение.

> - Мобильное приложение c версиями для Android и iOS;

Мобильное приложение имеет смысл эксплуатировать на мобильном устройстве. В крайнем случае, для целей тестирования можно использовать эмулятор. Контейнеры и виртуализация здесь не применимы.

> - Шина данных на базе Apache Kafka;

Данное программное обеспечение предполагает интенсивную обработку большого объёма данных. Для более эффективной работы следует минимизировать накладные расходы, а следовательно, лучше запускать на физической машине.

> - Elasticsearch кластер для реализации логирования продуктивного веб-приложения - три ноды elasticsearch, два logstash и две ноды kibana;

Да, в этом сценарии так же можно использовать контейнеризацию Docker, но необходимо соблюдать принципы построения кластера - нельзя размещать однотипные контейнеры на одной машине. Разнотипные контейнеры можно разместить на одной машине.

> - Мониторинг-стек на базе Prometheus и Grafana;

Связку из Prometheus и Grafana удобно разместить в виде контейнеров Docker. Файлы базы данных Prometheus, настройки его и Grafana пробрасываются на основную машину.

> - MongoDB, как основное хранилище данных для java-приложения;

Если СУБД может утилизировать все выделяемые ей мощности, то следует разместить её на физической машине. Если нагрузка не столь высока, то Docker statefull-контейнер вполне подойдёт для такой задачи.

> - Gitlab сервер для реализации CI/CD процессов и приватный (закрытый) Docker Registry.

На своих ресурсах Gitlab мы развернули в виде Docker-контейнера на базе официального образа. Registry и СУБД находятся внутри этого же контейнера, что противоречит рекомендациям по разграничению сервисов в контейнерах, но сильно упрощает жизнь администраторам. Используются statefull-контейнеры с пробросом данных СУБД, Registry и настроек в основную систему.

 Gitlab Runner (для реализации CI/CD) запускаются отдельными Docker stateless-контейнерами.

## Задача 3

> - Запустите первый контейнер из образа ***centos*** c любым тэгом в фоновом режиме, подключив папку ```/data``` из текущей рабочей директории на хостовой машине в ```/data``` контейнера;

```bash
docker run --rm --name="centos" -ti -d -v "$(pwd)/data:/data" docker.io/centos:7
```

> - Запустите второй контейнер из образа ***debian*** в фоновом режиме, подключив папку ```/data``` из текущей рабочей директории на хостовой машине в ```/data``` контейнера;

```bash
docker run --rm --name="debian" -ti -d -v "$(pwd)/data:/data" docker.io/debian:10
```

> - Подключитесь к первому контейнеру с помощью ```docker exec``` и создайте текстовый файл любого содержания в ```/data```;

```bash
docker exec -it centos bash -c "echo 'From CentOS' > /data/centos.txt"
```

> - Добавьте еще один файл в папку ```/data``` на хостовой машине;

```bash
/tmp ❯ echo "From host" > ./data/host.txt
```

> - Подключитесь во второй контейнер и отобразите листинг и содержание файлов в ```/data``` контейнера.

```bash
 /tmp ❯ docker exec -it debian bash
Emulate Docker CLI using podman. Create /etc/containers/nodocker to quiet msg.
root@ddde1bf9b81e:/# ls -l /data/
total 8
-rw-r--r-- 1 root root 11 May  4 13:36 centos.txt
-rw-r--r-- 1 root root 10 May  4 13:37 host.txt
root@ddde1bf9b81e:/# cat /data/centos.txt 
From CentOS
root@ddde1bf9b81e:/# cat /data/host.txt 
From host
root@ddde1bf9b81e:/# 
```

## Задача 4 (*)

> Воспроизвести практическую часть лекции самостоятельно.
>
> Соберите Docker образ с Ansible, загрузите на Docker Hub и пришлите ссылку вместе с остальными ответами к задачам.

[https://hub.docker.com/repository/docker/alekseishtepa/ansible](https://hub.docker.com/repository/docker/alekseishtepa/ansible)